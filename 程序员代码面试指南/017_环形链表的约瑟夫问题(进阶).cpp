/*
题目描述
据说著名犹太历史学家 Josephus 有过以下故事：在罗马人占领乔塔帕特后，39 个犹太人与 Josephus 及他的朋友躲到一个洞中，39 个犹太人决定宁愿死也不要被敌人抓到，于是决定了一种自杀方式，41 个人排成一个圆圈，由第 1 个人开始报数，报数到 3 的人就自杀，然后再由下一个人重新报 1，报数到 3 的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表得出最终存活的人的编号。

输入描述:
一行两个整数 n，m，n 表示链表的长度，m 表示每报数到 m 就自杀。

输出描述:
输出最后存活的人的编号(编号从 1 开始到 n)。

示例1
输入
5 2

输出
3

备注:
1 ≤ n , m ≤ 5000000
*/

// https://cloud.tencent.com/developer/article/1164687

// 下面首先列出 0~(N-1) 这 N 个人的原始编号如下：
// 0  1  2  3  …  N-3  N-2  N-1

// 根据前面曾经推导的过程可知，第一个出列人的编号一定是( M–1) % N 。例如，在 13 个人中，若报到 3 的人出列，则第一个出列人的编号一定是 (3–1) % 13 = 2，
// 注意这里的编号是从 0 开始的，因此编号 2 实际对应以 1 为起点中的编号 3。根据前面的描述，m 的前一个元素 (M–1) 已经出列，则出列 1 人后的列表如下：
// 0  1  2  3  …  M-3  M-2  ○  M  M+1  M+2  …  N-3  N-2  N-1
// 注意，上面的圆圈表示被删除的数。

// 根据规则，当有人出列之后，下一个位置的人又从 0 开始报数，则以上列表可调整为以下形式（即以 M 位置开始，N–1 之后再接上0、1、2……，形成环状）：
// M  M+1  M+2  …  N-2  N-1  0  1  …  M-3  M-2

// 按上面排列的顺序从 0 开始重新编号，可得到下面的对应关系：
// M  M+1  M+2 …   N-2      N-1      0    1        …  M-3 M-2
// 0  1    2   …   N-(M+2)  N-(M+1)  N-M  N-(M-1)  …  N-3 N-2

// 这里，假设上一行的数为 x，下一行的数为 y，则对应关系为:
// y = (x - M + N) % N            公式【1】
// 或者
// x = (y + M) % N                公式【2】

// 通过上表的转换，将出列 1 人后的数据重新组织成了 0～（N–2）共 N–1 个人的列表，
// 继续求 N–1 个参与人员，按报数到 M–1 即出列，求解最后一个出列者最初在圆形队列中的编号。

// F(1) = 0
// F(N) = [F(N - 1) + M] % N      (N>1)

#include <iostream>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    int out = 0;
    for(int i = 2; i <= n; i++) {
        out = (out + m) % i;
    }
    cout << out + 1; // 以上取余方式是从 0 开始编号，应此结果需加一
    
    return 0;
}